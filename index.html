<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>í•´ì•¼ í• ê¹Œìš”...? ğŸ¤”</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Sans+KR">
    <style>
        /* --- Reset and Basic Styles --- */
        body {
            font-family: 'Noto Sans KR', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f7f9fc; /* Light background */
            color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        .container {
            width: 90%;
            max-width: 800px;
            background-color: white;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        h1 {
            font-size: 2.5rem;
            font-weight: bold;
            text-align: center;
            margin-bottom: 1rem;
        }

        h2 {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
            margin-top: 1.5rem;
        }

        /* --- Input Fields --- */
        .input-group {
            margin-bottom: 1rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: bold;
        }

        input[type="text"],
        input[type="password"],
        textarea,
        select {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ced4da;
            border-radius: 0.5rem;
            font-size: 1rem;
            margin-bottom: 0.5rem;
            box-sizing: border-box; /* Important for consistent sizing */
            transition: border-color 0.2s ease;
        }

        input[type="text"]:focus,
        input[type="password"]:focus,
        textarea:focus,
        select:focus
         {
            border-color: #80bdff;
            outline: 0;
            box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
        }
        input[type="file"] {
           width: 100%;
           padding: 0.75rem;
           font-size: 1rem;
        }


        /* --- Buttons --- */
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease;
            margin-right: 0.5rem;
        }

        button:hover {
            background-color: #367C39;
        }

        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        /* --- Radio Buttons --- */
        .radio-group {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .radio-group label {
            padding: 0.5rem 1rem;
            border: 1px solid #ced4da;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease;
        }

        .radio-group input[type="radio"] {
            display: none; /* Hide the actual radio button */
        }

        .radio-group input[type="radio"]:checked + label {
            background-color: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }

        /* --- Result Area --- */
        #resultArea {
            margin-top: 1.5rem;
            padding: 1rem;
            border: 1px solid #ced4da;
            border-radius: 0.5rem;
        }
        #resultArea p{
             margin-bottom: 0.3rem;
        }

        /* --- Progress Bar --- */
        #progressBar {
            width: 100%;
            height: 10px;
            background-color: #ddd;
            border-radius: 5px;
            margin-top: 0.5rem;
            overflow: hidden;  /* Ensure the inner bar doesn't overflow */
        }

        #progressBarInner {
            height: 100%;
            background-color: #4CAF50;
            width: 0%; /* Initial width */
            border-radius: 5px;
            transition: width 0.5s ease; /* Smooth transition for width changes */
        }

        /* --- Pulse Animation --- */
        @keyframes pulse {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.05);
                opacity: 0.7;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .pulse {
            animation: pulse 2s infinite; /* Apply the pulse animation */
        }


        /* --- Error Message --- */
        .error {
            color: red;
            margin-top: 0.5rem;
        }
        .hidden {
            display: none;
        }
                /* --- Camera and Audio Styles --- */
        #cameraPreview {
            width: 100%;
            max-width: 500px; /* Adjust as needed */
            border: 1px solid #ced4da;
            border-radius: 0.5rem;
        }

        #audioControls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        #audioRecording {
            width: 100%;
            margin-top: 0.5rem;
        }

    </style>
</head>
<body>
    <div class="container">
        <h1>í•´ì•¼ í• ê¹Œìš”...? ğŸ¤”</h1>

        <h2>API ì„¤ì •</h2>
        <div class="input-group">
            <label for="provider">API ì œê³µì:</label>
            <select id="provider" onchange="updateModelOptions()">
                <option value="openai">OpenAI</option>
                <option value="gemini">Google Gemini</option>
            </select>
        </div>
        <div class="input-group">
            <label for="apiKey">API í‚¤:</label>
            <input type="password" id="apiKey" placeholder="API í‚¤ë¥¼ ì…ë ¥í•˜ì„¸ìš”">
            <button onclick="saveApiKey()">ì €ì¥</button>
            <button onclick="clearApiKey()">ì‚­ì œ</button>
        </div>

        <div class="input-group">
            <label for="model">ëª¨ë¸:</label>
            <select id="model"></select>
        </div>

        <h2>LLM ì„¤ì •</h2>
          <div class="input-group">
            <label for="temperature">Temperature:</label>
            <input type="number" id="temperature" value="0.7" min="0.1" max="2.0" step="0.1">
          </div>
            <div class="input-group">
                <label for="topP">Top P:</label>
                <input type="number" id="topP" value="0.9" min="0.1" max="1.0" step="0.05">
            </div>
            <div class="input-group">
                <label for="topK">Top K:</label>
                <input type="number" id="topK" value="50" min="1" max="100" step="1">
            </div>
            <div class="input-group">
                <label for="maxTokens">Max Tokens:</label>
                <input type="number" id="maxTokens" value="256" min="1" max="2048" step="1">
            </div>
            <div class="input-group">
                <label for="repeatPenalty">Repeat Penalty:</label>
                <input type="number" id="repeatPenalty" value="1.1" min="0.1" max="2.0" step="0.05">
            </div>

        <h2>TTS ì„¤ì •</h2>
           <div class="input-group">
                <label for="ttsVoice">TTS ìŒì„±:</label>
                <select id="ttsVoice"></select>
            </div>
            <div class="input-group">
                <label for="ttsSpeed">TTS ì†ë„:</label>
                <input type="range" id="ttsSpeed" min="0.5" max="2" step="0.1" value="1">
                <span id="ttsSpeedValue">1</span>
           </div>

        <h2>ì…ë ¥ ìœ í˜•</h2>
        <div class="radio-group">
            <input type="radio" id="inputTypeText" name="inputType" value="text" checked>
            <label for="inputTypeText">í…ìŠ¤íŠ¸</label>

            <input type="radio" id="inputTypeImage" name="inputType" value="image">
            <label for="inputTypeImage">ì´ë¯¸ì§€</label>

            <input type="radio" id="inputTypeCamera" name="inputType" value="camera">
            <label for="inputTypeCamera">ì¹´ë©”ë¼</label>

            <input type="radio" id="inputTypeAudio" name="inputType" value="audio">
            <label for="inputTypeAudio">ì˜¤ë””ì˜¤</label>
        </div>


        <div class="input-group" id="textInputGroup">
            <label for="question">ì§ˆë¬¸:</label>
            <textarea id="question" placeholder="ì§ˆë¬¸ì„ ì…ë ¥í•˜ì„¸ìš”"></textarea>
        </div>

        <div class="input-group hidden" id="imageInputGroup">
            <label for="imageUpload">ì´ë¯¸ì§€ ì—…ë¡œë“œ:</label>
            <input type="file" id="imageUpload" accept="image/*">
        </div>

          <div class="input-group hidden" id="cameraInputGroup">
            <label for="cameraPreview">ì¹´ë©”ë¼ ë¯¸ë¦¬ë³´ê¸°:</label>
            <video id="cameraPreview" autoplay playsinline></video>
            <button onclick="captureImage()">ì‚¬ì§„ ì°ê¸°</button>
            <canvas id="capturedImageCanvas" style="display: none;"></canvas>
        </div>

        <div class="input-group hidden" id="audioInputGroup">
            <label>ì˜¤ë””ì˜¤ ë…¹ìŒ:</label>
            <div id="audioControls">
                <button id="recordButton" onclick="startRecording()">ë…¹ìŒ ì‹œì‘</button>
                <button id="stopButton" onclick="stopRecording()" disabled>ë…¹ìŒ ì¤‘ì§€</button>
            </div>
            <audio id="audioRecording" controls></audio>
        </div>



        <button onclick="analyze()" id="analyzeButton">ë¶„ì„</button>

        <div id="resultArea">
            <p id="probability"></p>
            <div id="progressBar"><div id="progressBarInner"></div></div>
            <p id="reason"></p>
            <audio id="ttsAudio" controls></audio>
        </div>
        <div id="errorMessage" class="error"></div>

    </div>

    <script>
        // --- Global Variables ---
        let currentProvider = 'openai';
        let mediaStream = null;
        let mediaRecorder = null;
        let audioChunks = [];
        let ttsVoices = [];


        // --- Model Options (You can expand these) ---
        const openAIModels = ["gpt-3.5-turbo", "gpt-4-turbo-preview","gpt-4"];  // Add more
        const geminiModels = ["gemini-1.5-pro-002", "gemini-1.5-flash-002","gemini-1.0-pro-002"];  // Add more

        // --- DOM Element References ---
        const providerSelect = document.getElementById('provider');
        const apiKeyInput = document.getElementById('apiKey');
        const modelSelect = document.getElementById('model');
        const questionTextarea = document.getElementById('question');
        const imageUploadInput = document.getElementById('imageUpload');
        const analyzeButton = document.getElementById('analyzeButton');
        const resultArea = document.getElementById('resultArea');
        const probabilityText = document.getElementById('probability');
        const progressBarInner = document.getElementById('progressBarInner');
        const reasonText = document.getElementById('reason');
        const ttsAudio = document.getElementById('ttsAudio');
        const errorMessage = document.getElementById('errorMessage');
        const textInputGroup = document.getElementById('textInputGroup');
        const imageInputGroup = document.getElementById('imageInputGroup');
        const cameraInputGroup = document.getElementById('cameraInputGroup');
        const audioInputGroup = document.getElementById('audioInputGroup');
        const cameraPreview = document.getElementById('cameraPreview');
        const capturedImageCanvas = document.getElementById('capturedImageCanvas');
        const recordButton = document.getElementById('recordButton');
        const stopButton = document.getElementById('stopButton');
        const audioRecording = document.getElementById('audioRecording');
        const ttsVoiceSelect = document.getElementById('ttsVoice');
        const ttsSpeedInput = document.getElementById('ttsSpeed');
        const ttsSpeedValue = document.getElementById('ttsSpeedValue');


        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            loadApiKeys();
            updateModelOptions();
            setupInputTypeSwitching();
            populateTTSVoices();
            setupTTSEvents();

            // Try to start camera stream on load (for camera input)
             startCameraStream();
        });

        function setupTTSEvents() {
            ttsSpeedInput.addEventListener('input', () => {
                ttsSpeedValue.textContent = ttsSpeedInput.value;
            });
        }

        function populateTTSVoices() {
            // Wait for voices to be loaded
            window.speechSynthesis.onvoiceschanged = () => {
                ttsVoices = window.speechSynthesis.getVoices();
                ttsVoiceSelect.innerHTML = ''; // Clear existing options

                ttsVoices.forEach(voice => {
                    const option = document.createElement('option');
                    option.textContent = `${voice.name} (${voice.lang})`;
                    option.value = voice.name;
                    ttsVoiceSelect.appendChild(option);
                });
            };
        }

        function speakText(text) {
            if (!text) return;
            const utterance = new SpeechSynthesisUtterance(text);
            const selectedVoiceName = ttsVoiceSelect.value;
            const selectedVoice = ttsVoices.find(voice => voice.name === selectedVoiceName);

            if (selectedVoice) {
                utterance.voice = selectedVoice;
            }
            utterance.rate = parseFloat(ttsSpeedInput.value);
            window.speechSynthesis.speak(utterance);
        }


        function setupInputTypeSwitching() {
            const inputTypes = document.querySelectorAll('input[name="inputType"]');
            inputTypes.forEach(input => {
                input.addEventListener('change', () => {
                    textInputGroup.classList.add('hidden');
                    imageInputGroup.classList.add('hidden');
                    cameraInputGroup.classList.add('hidden');
                    audioInputGroup.classList.add('hidden');

                    if (input.value === 'text') {
                        textInputGroup.classList.remove('hidden');
                    } else if (input.value === 'image') {
                        imageInputGroup.classList.remove('hidden');
                    } else if (input.value === 'camera') {
                        cameraInputGroup.classList.remove('hidden');
                        startCameraStream(); // Start camera when switching
                    } else if (input.value === 'audio') {
                        audioInputGroup.classList.remove('hidden');
                    }
                });
            });
        }



        // --- API Key Management ---
        function saveApiKey() {
            const provider = providerSelect.value;
            const apiKey = apiKeyInput.value;
            if (apiKey) {
                localStorage.setItem(`${provider}_apiKey`, apiKey);
                alert(`${provider} API í‚¤ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.`);
            }
        }

        function clearApiKey() {
            const provider = providerSelect.value;
            localStorage.removeItem(`${provider}_apiKey`);
            apiKeyInput.value = '';
            alert(`${provider} API í‚¤ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.`);
        }

        function loadApiKeys() {
            const provider = providerSelect.value;
            const storedApiKey = localStorage.getItem(`${provider}_apiKey`);
            if (storedApiKey) {
                apiKeyInput.value = storedApiKey;
            }
        }

        function updateModelOptions() {
            currentProvider = providerSelect.value;
            modelSelect.innerHTML = ''; // Clear existing options

            const models = currentProvider === 'openai' ? openAIModels : geminiModels;
            models.forEach(model => {
                const option = document.createElement('option');
                option.value = model;
                option.textContent = model;
                modelSelect.appendChild(option);
            });

            loadApiKeys(); // Reload API key when provider changes
        }

        // --- Camera Functions ---
       async function startCameraStream() {
            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
                cameraPreview.srcObject = mediaStream;
                cameraPreview.style.display = 'block';
            } catch (err) {
                console.error('Error accessing camera:', err);
                errorMessage.textContent = "ì¹´ë©”ë¼ ì ‘ê·¼ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: " + err.message;
                // Hide camera-related elements if camera access fails
                cameraInputGroup.classList.add('hidden');
           }
        }

        function captureImage() {
            if (!mediaStream) return;

            const context = capturedImageCanvas.getContext('2d');
            capturedImageCanvas.width = cameraPreview.videoWidth;
            capturedImageCanvas.height = cameraPreview.videoHeight;
            context.drawImage(cameraPreview, 0, 0, cameraPreview.videoWidth, cameraPreview.videoHeight);

             // Stop the camera stream after capturing
              if(mediaStream) {
                  mediaStream.getTracks().forEach(track => track.stop());
                  mediaStream = null; // Reset the stream
                  cameraPreview.srcObject = null; // Clear the video element
              }

            // Trigger the analysis with the captured image
            analyze();
        }


        // --- Audio Recording Functions ---

        async function startRecording() {
            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(mediaStream);
                audioChunks = [];

                mediaRecorder.ondataavailable = event => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    const audioUrl = URL.createObjectURL(audioBlob);
                    audioRecording.src = audioUrl;
                     // Stop the mic stream after capturing
                      if(mediaStream) {
                          mediaStream.getTracks().forEach(track => track.stop());
                          mediaStream = null; // Reset the stream
                      }
                };

                mediaRecorder.start();
                recordButton.disabled = true;
                stopButton.disabled = false;
            } catch (err) {
                console.error('Error accessing microphone:', err);
                 errorMessage.textContent = "ë§ˆì´í¬ ì ‘ê·¼ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: " + err.message;
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                recordButton.disabled = false;
                stopButton.disabled = true;
            }
        }


        // --- Analysis Function (Main Logic) ---
        async function analyze() {
            errorMessage.textContent = ''; // Clear previous errors
            resultArea.style.display = 'none'; // Hide previous results
            const provider = providerSelect.value;
            const apiKey = apiKeyInput.value;
            const model = modelSelect.value;
            const inputType = document.querySelector('input[name="inputType"]:checked').value;


            if (!apiKey) {
                errorMessage.textContent = 'API í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.';
                return;
            }

            let inputText = '';
            let imageData = null;

             // LLM settings
            const temperature = parseFloat(document.getElementById('temperature').value);
            const topP = parseFloat(document.getElementById('topP').value);
            const topK = parseInt(document.getElementById('topK').value);
            const maxTokens = parseInt(document.getElementById('maxTokens').value);
            const repeatPenalty = parseFloat(document.getElementById('repeatPenalty').value);



            if (inputType === 'text') {
                inputText = questionTextarea.value;
                if (!inputText) {
                    errorMessage.textContent = 'ì§ˆë¬¸ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.';
                    return;
                }
            } else if (inputType === 'image') {
                if (imageUploadInput.files.length > 0) {
                    imageData = await readFileAsBase64(imageUploadInput.files[0]);
                 } else if (capturedImageCanvas.width > 0) { // Check if canvas has content
                      imageData = capturedImageCanvas.toDataURL('image/jpeg').split(',')[1]; // Get base64 from canvas
                } else {
                    errorMessage.textContent = 'ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ê±°ë‚˜ ì¹´ë©”ë¼ë¡œ ì‚¬ì§„ì„ ì°ì–´ì£¼ì„¸ìš”.';
                    return;
                }

            } else if (inputType === 'audio') {
                  if (audioChunks.length === 0) {
                      errorMessage.textContent = "ì˜¤ë””ì˜¤ë¥¼ ë…¹ìŒí•´ì£¼ì„¸ìš”.";
                      return;
                  }
                  const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                  // Convert the audio blob to base64
                  try {
                        inputText = await convertAudioBlobToBase64(audioBlob);
                       // inputText = await transcribeAudio(audioBlob, apiKey, provider);
                  }
                  catch (error) {
                        errorMessage.textContent = "ì˜¤ë””ì˜¤ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: " + error.message;
                        return;

                  }
             }

            analyzeButton.disabled = true;
            progressBarInner.style.width = '0%';
            progressBarInner.classList.add('pulse');
            resultArea.style.display = 'block'; // Show the result area (for the progress bar)

           try {
                let result;
                if (provider === 'openai') {
                    result = await analyzeWithOpenAI(apiKey, model, inputText, imageData, temperature, topP, topK, maxTokens, repeatPenalty);
                } else if (provider === 'gemini') {
                    result = await analyzeWithGemini(apiKey, model, inputText, imageData,temperature, topP, topK, maxTokens, repeatPenalty);
                }

              if (result) {
                    displayResult(result);
                }

            } catch (error) {
                errorMessage.textContent = "ë¶„ì„ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: " + error.message;
            } finally {
                analyzeButton.disabled = false;
                progressBarInner.classList.remove('pulse');
            }
        }

        //--- Audio Processing ---
       function convertAudioBlobToBase64(audioBlob) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => {
              resolve(reader.result.split(',')[1]); // Base64 data, without the data:audio/webm;base64, part
            };
            reader.onerror = reject;
            reader.readAsDataURL(audioBlob);
          });
        }


       async function transcribeAudio(audioBase64, apiKey, provider) {

            const headers = {
                'Authorization': `Bearer ${apiKey}`,
                'Content-Type': 'application/json'
            };
            let data = {};
            let apiUrl = '';

            if(provider === 'openai'){
                apiUrl = 'https://api.openai.com/v1/audio/transcriptions';
                data = {
                    "model": "whisper-1", // OpenAI Whisper model
                    "file": `data:audio/webm;base64,${audioBase64}`, // Include the base64 data directly
                 };

            } else if (provider === 'gemini'){
              //Google Cloud Speech-to-Text API  - gemini ìš© STT ê°€ ì—†ìŒ.
               return;

            } else{
                throw new Error("ì§€ì›í•˜ì§€ì•ŠëŠ” provider ì…ë‹ˆë‹¤." + provider);
            }

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(data)
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error("STT API Error: " + (errorData.error?.message || response.statusText));
            }
            const responseData = await response.json();
            return provider === 'openai' ? responseData.text : (responseData.results[0]?.alternatives[0]?.transcript || "");


        }

        // --- API Call Functions ---

        async function analyzeWithOpenAI(apiKey, model, inputText, imageData, temperature, topP, topK, maxTokens, repeatPenalty) {
            const apiUrl = 'https://api.openai.com/v1/chat/completions';
            const headers = {
                'Authorization': `Bearer ${apiKey}`,
                'Content-Type': 'application/json'
            };
            let messages = [];
             // System message for analysis
             messages.push({
                    "role": "system",
                    "content": `
                        ë‹¹ì‹ ì€ ì „ë¬¸ ë¶„ì„ê°€ì…ë‹ˆë‹¤. ì£¼ì–´ì§„ ì •ë³´ì™€ ì§ˆë¬¸ì„ ë¶„ì„í•˜ì—¬, 'ì˜ˆ' ë˜ëŠ” 'ì•„ë‹ˆì˜¤'ë¡œ ëŒ€ë‹µí•  ê°€ëŠ¥ì„±ì„ ë°±ë¶„ìœ¨(0-100)ë¡œ ì œì‹œí•˜ê³ , ê·¸ ì´ìœ ë¥¼ ì„¤ëª…í•´ì£¼ì„¸ìš”.  í•´ë‹¹ë˜ëŠ” ê²½ìš° ì¶œì²˜ë¥¼ ì¸ìš©í•˜ì„¸ìš”.

                        ì˜ˆì‹œ:
                        {"probability": 75, "reason": "í˜„ì¬ ì‹œì¥ ë™í–¥ê³¼ ì „ë¬¸ê°€ ì˜ê²¬ì— ë”°ë¥´ë©´, í•´ë‹¹ ì£¼ì‹ì€ ê°•ë ¥í•œ ì„±ì¥ ì ì¬ë ¥ì„ ë³´ì…ë‹ˆë‹¤. ì¶œì²˜:êµ¬ê¸€"}
                    `
                });

            if (imageData) {
                 // For image input, use a combined user message with text and image
                messages.push({
                    "role": "user",
                    "content": [
                        {
                            "type": "text",
                            "text": inputText ? `${inputText}\n\nê´€ë ¨ ì •ë³´:\n${await performDDGSearch(inputText)}`: "ì‚¬ì§„ì— ëŒ€í•´ ë¶„ì„í•´ì£¼ì„¸ìš”."
                        },
                        {
                            "type": "image_url",
                            "image_url": {
                                "url": `data:image/jpeg;base64,${imageData}`
                            }
                        }
                    ]
                });
            } else {
                // For text-only input
                 messages.push({
                    "role": "user",
                    "content": inputText + `\n\nê´€ë ¨ ì •ë³´:\n${await performDDGSearch(inputText)}`
                });

            }


            const data = {
                model: model,
                messages: messages,
                 max_tokens: maxTokens,
                temperature: temperature,
                top_p: topP,
                n: 1,
                stop: null,
                 presence_penalty: repeatPenalty, // Assuming presence_penalty maps to repeatPenalty
                frequency_penalty: 0,  // You might need to adjust how you handle frequency penalty

            };

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(data)
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error("OpenAI API Error: " + (errorData.error?.message || response.statusText));
            }

            const responseData = await response.json();
           // Extract and return the relevant information
            try {

                 const contentStr = responseData.choices[0].message.content;
                 const contentJson = JSON.parse(contentStr);
                 return {
                      probability: contentJson.probability,
                      reason: contentJson.reason
                  };

            } catch (error) {
                 throw new Error("Invalid JSON response from OpenAI: " + error.message);
            }
        }



       async function analyzeWithGemini(apiKey, model, inputText, imageData, temperature, topP, topK, maxTokens, repeatPenalty) {

             // Construct the endpoint URL based on the selected model
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
            const headers = {
                'Content-Type': 'application/json'
            };

             let requestData = {
                contents: [],
                generationConfig: {
                    temperature: temperature,
                    topP: topP,
                    topK: topK,
                    maxOutputTokens: maxTokens, // Corrected parameter name
                   // Gemini API doesn't have a direct equivalent for repeat_penalty (presence_penalty),
                   // so we'll omit it. Consider using a different approach if repetition is a major concern.
                }
            };

              // System prompt (added as a separate part in the content)
            requestData.contents.push({
                role: "model",
                parts: [{
                    text: `
                       ë‹¹ì‹ ì€ ì „ë¬¸ ë¶„ì„ê°€ì…ë‹ˆë‹¤. ì£¼ì–´ì§„ ì •ë³´ì™€ ì§ˆë¬¸ì„ ë¶„ì„í•˜ì—¬, 'ì˜ˆ' ë˜ëŠ” 'ì•„ë‹ˆì˜¤'ë¡œ ëŒ€ë‹µí•  ê°€ëŠ¥ì„±ì„ ë°±ë¶„ìœ¨(0-100)ë¡œ ì œì‹œí•˜ê³ , ê·¸ ì´ìœ ë¥¼ ì„¤ëª…í•´ì£¼ì„¸ìš”.  í•´ë‹¹ë˜ëŠ” ê²½ìš° ì¶œì²˜ë¥¼ ì¸ìš©í•˜ì„¸ìš”.

                        ì˜ˆì‹œ:
                        {"probability": 75, "reason": "í˜„ì¬ ì‹œì¥ ë™í–¥ê³¼ ì „ë¬¸ê°€ ì˜ê²¬ì— ë”°ë¥´ë©´, í•´ë‹¹ ì£¼ì‹ì€ ê°•ë ¥í•œ ì„±ì¥ ì ì¬ë ¥ì„ ë³´ì…ë‹ˆë‹¤. ì¶œì²˜:êµ¬ê¸€"}
                    `
                }]
            });

             if (imageData) {
                 const imagePart = {
                    inlineData: {
                        mimeType: "image/jpeg",  // Assuming JPEG, adjust if necessary
                        data: imageData
                    }
                };

                 const textPart = {
                     text: inputText ? `${inputText}\n\nê´€ë ¨ ì •ë³´:\n${await performDDGSearch(inputText)}` : "ì‚¬ì§„ì— ëŒ€í•´ ë¶„ì„í•´ì£¼ì„¸ìš”."
                 };
                  // Add both text and image parts within a *single* user role entry
                 requestData.contents.push({
                    role: "user",
                    parts: [textPart, imagePart]  // Both parts in one user message
                });

             } else {
                requestData.contents.push({
                    role: "user",
                    parts: [{ text: inputText + `\n\nê´€ë ¨ ì •ë³´:\n${await performDDGSearch(inputText)}`}]
                });

            }

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(requestData)
            });

           if (!response.ok) {
                const errorData = await response.json(); // Attempt to get JSON error details
                throw new Error(`Gemini API Error: ${errorData.error?.message || response.statusText}`);
           }

            const responseData = await response.json();

            try {

                  const contentStr = responseData.candidates[0].content.parts[0].text;
                  const contentJson = JSON.parse(contentStr);
                  return {
                        probability: contentJson.probability,
                        reason: contentJson.reason
                    };

            } catch (error) {
                throw new Error("Invalid JSON response from Gemini: " + error.message);
            }
        }



        // --- Helper Functions ---

        async function performDDGSearch(query) {
            //  DuckDuckGo Search (Simplified -  CORS proxy needed for a browser)
            //  In a real application, do this on the server.
            if (!query) return "";
            try {
                 const proxyUrl = "https://cors-anywhere.herokuapp.com/"; // Example CORS proxy
                const ddgUrl = `https://api.duckduckgo.com/?q=${encodeURIComponent(query)}&format=json&pretty=1`;
                const response = await fetch(proxyUrl + ddgUrl);

                if (!response.ok) {
                    throw new Error(`DuckDuckGo Search failed: ${response.statusText}`);
                }
                const data = await response.json();
                // Extract relevant information (adjust as needed)
                let results = [];
                if (data.AbstractText) {
                    results.push(data.AbstractText);
                }
                if (data.RelatedTopics && Array.isArray(data.RelatedTopics)) {
                    data.RelatedTopics.forEach(topic => {
                        if (topic.Text) {
                            results.push(topic.Text);
                        }
                    });
                }  //From previous response

                return results.join('\n\n');

            } catch (error) {
                console.error("Error performing DuckDuckGo search:", error);
                errorMessage.textContent = "DuckDuckGo ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: " + error.message;
                return ""; // Return empty string on error
            }
        }

        function readFileAsBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result.split(',')[1]); // Get base64 data
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        function displayResult(result) {
            if (result.probability !== undefined && result.reason) {
                probabilityText.textContent = `í™•ë¥ : ${result.probability}%`;
                progressBarInner.style.width = `${result.probability}%`;
                reasonText.textContent = `ì´ìœ : ${result.reason}`;
                speakText(result.reason);  //TTS
                resultArea.style.display = 'block';
            } else {
                errorMessage.textContent = 'ìœ íš¨í•œ ê²°ê³¼ë¥¼ ë°›ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.';
            }
        }


    </script>
</body>
</html>
